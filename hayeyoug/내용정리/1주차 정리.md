# 1주차 내용 정리

### 프로젝트 생성
- 스프링 부트 스타터(https://start.spring.io/)
  - 사용 기능 : web, thymleaf, jpa, h2, lombok, validation

### thymleaf
- 템플릿 엔진으로 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용한다.
- 비슷한 템플릿 엔진으로는 JSP가 있다.
- 기본 html 문법과 완전히 동일하지 않다.
    
### ORM (Object-Relational Mapping)
  - 애플리케이션인 class와 RDB(관계형 데이터베이스)의 테이블을 매핑(연결)한다는 뜻이며, 기술 적으로는 어플리케이션 객체를 RDB 테이블에 자동으로 영속화해주는 것이라고 보면 된다.
  - 장점 
    1. SQL문이 아닌 Method를 통해 DB를 조작할 수 있음 -> 개발자는 로직을 구성하는데만 집중할 수 있음
    1. 객체지향적인 코드 작성이 가능함
    1. 유지보수에 유리하다. (ex. MySQL을 사용하다가 PostgreSQL로 변환하면 새로 쿼리를 짜야하는 경우가 생기지만 ORM을 사용한다면 쿼리를 수정할 필요가 없음)
  - 단점
    1. 복잡하고 무거운 Query는 속도를 위해 볉도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있음
    2. 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있음

### JPA(Java Persistence API)
- Java 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용하는 인터페이스 모음
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
- 인터페이스이기 때문에 Hibernate, OpenJPA 등이 JPA를 구현
- 인터페이스 
  - 일종의 매개체, 자바에서 추상 클래스는 추상 메소드 뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있다. 하지만 인터페이스는 오로지 추상 메소드와 상수만을 포함할 수 있다.
  - 인터페이스는 추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수는 없다. 따라서 인터페이스가 포함하고 있는 추상 메소드를 구현해 줄 클래스를 작성해야만 합니다.

### h2
- 장점 
1. 따로 설치가 필요없다.
2. 용량이 매우 가볍다.
3. 웹용 콘솔 (쿼리툴) 제공하여 개발용 로컬DB로 사용 용이
- 특징
1. JAVA로 작성된 오픈소스 RDBMS
1. 스프링 부트가 지원하는 인메모리 관계형 데이터베이스
2. 로컬 환경, 테스트 환경에서 많이 쓰임
- 사용 방법
- h2를 다운 받고 압축 해제 후 bin 디렉토리 아래의 h2.sh(맥의 경우)를 실행한다.
- 데이터베이스 파일 생성 방법
  `jdbc:h2:~/jpashop` (최소 한번)
  `~/jpashop.mv.db` 파일 생성 확인
  이후 부터는 `jdbc:h2:tcp://localhost/~/jpashop` 이렇게 접속

### lombok
- 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리
- ex) Getter, Setter, Equals, ToString...

### validation
- @Null, @Notnull.. 등의 애노테이션 이용가능

### 핵심 라이브러리 
- 스프링 MVC
- 스프링 ORM
- JPA, 하이버네이트
- 스프링 데이터 JPA 

### 기타 라이브러리
- H2 데이터베이스 클라이언트 
- 커넥션 풀: 부트 기본은 HikariCP WEB(thymeleaf)
  - 애플리케이션 로딩 시점에 Connection 객체를 미리 생성하고, 애플리케이션에서 데이터베이스에 연결이 필요한 경우 미리 준비된 Connection 객체를 사용하여 애플리케이션의 성능을 향상시켜줌
  - #### Connection 객체를 생성하는 방법
    1. 애플리케이션에서 DB 드라이버를 통해 커넥션을 조회한다.
    2. DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. (3 way handshake와 같은 네트워크 연결 동작 발생)
    3. DB 드라이버는 TCP/IP 커넥션이 연결되면 아이디와 패스워드, 기타 부가 정보를 DB에 전달한다.
    4. DB는 아이디, 패스워드를 통해 내부 인증을 거친 후 내부에 DB를 생성한다.
    5. DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
    6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.
  - 위처럼 Connection 객체를 DB를 연결할 때마다 새로 만드는 것은 비용이 많이 들며, 굉장히 비효율적이다.
  - 

### 엔티티
- 데이터의 집합을 의미함
- 엔티티의 특징
  1. 식별자 : 유일한 식별자를 갖고 있어야 한다. ex) 주민번호, ID 등
  2. 2개 이상의 인스턴스가 있어야 한다.
  3. 반드시 속성을 갖고 있어야 한다.
  4. 관계 - 다른 엔티티와 최소 한 개 이상 관계가 있어야 한다.
  
- @Entity 애노테이션
  - JPA에서 엔티티란 DB 테이블에 대응하는 하나의 클래스라고 생각할 수 있다.
  - @Entity가 붙은 클래스는 JPA가 관리해주며, JPA를 사용하여 DB 테이블과 매핑할 클래스에 붙인다.

### 리포지토리
- 리포지토리 : 엔티티에 의해 생성된 데이터베이스 테이블에 접근하는 메서드들 (findALl, save 등)으 사용하기 위한 인터페이스
- CRUD를 어떻게 처리할지 정의하는 계층

### EntityManager
- 모든 JPA의 동작은 Entity들을 기준으로 돌아가는데, 이 때 Entity들을 관리하는 역할을 한다.
  1. (요청)
  1. EntityManager 만들어짐
  1. Entity들을 영속성 컨텍스트에 생성 -> Entity 영속화
  4. Entity Manager가 영속성 컨텍스트를 기반으로 요청(생성, 조회, 수정, 삭제)처리

### 영속성 컨텍스트 (Persistence Context)
- 엔티티를 영구 저장하는 환경이다.
- 엔티티의 생명 주기
  1. 비영속 : 영속성 컨텍스트와 연관이 없는 상태
  2. 영속 : 영속성 컨텍스트에서 관리 중인 상태
  3. 준영속 : 영속성 컨텍스트에 저장되어 있었으나 분리된 상태
  4. 삭제 : 영속성 컨텍스트에서 완전히 삭제된 상태
- @Entity 애노테이션을 갖는 엔티티 인스턴스를 막 생성했을 때는 영속성 컨텍스트에서 관리하지 않음
- EntityManager의 persist 메소드를 사용하영 영속상태로 변경할 수 있다.
  - EntityManager em; em.persist(someEntity); 
